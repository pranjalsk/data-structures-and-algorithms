### Multithreaded Application in C#

#### Description: 
Consider that you are creating a simplified e-commerce system. The system consists of multiple chicken retailers (clients) and a single chicken farm (server). The system consists of the major components shown in the diagram below.

#### An Operation Scenario of the e-commerce system is outlined below:
(1) The ChickenFarm uses a pricing model to calculate the chicken price. If the new price is lower than the previous price, it emits an event and calls the event handlers in the retailers that have subscribed to the event.
(2) A Retailer evaluates the price, generates an OrderObject (consisting of multiple values), and sends the order to the Encoder to convert the order object into a plain string.
(3) The Encoder converts the object into a string.
(4) The Encoder sends the encoded string back to the caller.
(5) The Retailer sends the encoded string to one of the free cells in the MultiCellBuffer.
(6) The ChickenFarm receives the encoded string from the MultiCellBuffer and sends the string to the Decoder for decoding.
(7) The Decoder sends the OrderObject to the ChickenFarm. The decoded object must contain the same values generated by the Retailer.
(8) The ChickenFarm creates a new thread to process the order;
(9) The OrderProcessingThread processes the order, e.g., checks the credit card number and calculates the amount.
(10) The OrderProcessingThread sends a confirmation to the retailer and prints the order.

#### Components
in the diagram are explained in details as follows, with their grades allocation:
1. ChickenFarm is a class on the server side: It will be started as a thread by the Main method and will perform a number of service functions. It uses a PricingModel to determine the chicken prices. It defines a price-cut event that can emit an event and call the event handlers in the Retailers if there is a price-cut according to the PricingModel. It receives the orders (in string) from the MultiCellBuffer. It calls the Decoder to convert the string into the order object. For each order, it starts a new thread (resulting in multiple threads for processing multiple orders*) from OrderProcessing class (or method) to process the order based on the current price. There is a counter p in the ChickenFarm. After p (e.g., p = 10) price cuts have been made, the ChickenFarm thread will terminate.
2. PricingModel: It can be a class or a method in ChickenFarm class. It decides the price of chickens. It can increase price or cut the price. You can define a mathematical model (formula) to determine the price based on the order received within a given time period and the number of chickens the farm can produce in the same time period. You can use a random model to generate the prices. However, you must make sure that your model will allow the price goes up some time and goes down some other time. 
3. OrderProcessing is a class or a method in a class on server side. Whenever an order needs to be processed, a new thread is instantiated from this class (or method) to process the order. It will check the validity of the credit card number. You can define your own credit card format, for example, the credit card number from the retailers must be a number registered to the ChickenFarm, or a number between two given numbers (e.g., between 5000 and 7000). Each OrderProcessing thread will calculate the total amount of charge, e.g., unitPrice*NoOfChickens + Tax + shippingHandling. It will send a confirmation to the retailer when an order is completed. The confirmation must be implemented using a callback method
4. Retailer1 through RetailerN, where N = 5, each retailer is a thread instantiated from the same class (or the same method) in a class. The retailers’ actions are event-driven. Each retailer contains a callback method (event handler) for the ChickenFarm to call when a price-cut event occurs. The retailer will calculate the number of chickens to order, for example, based on the need and the difference between the previous price and the current price. The thread will terminate after the ChickenFarm thread has terminated. Each order is an OrderClass object. The object is sent to the Encoder for encoding. The encoded string is sent back to the retailer. Then, the retailer will send the order in String format to the MultiCellBuffer. Before sending the order to the MultiCellBuffer, a time stamp must be saved. When the confirmation of order completion is received, the time of the order will be calculated and saved (or printed). 
5. OrderClass is a class that contains at least the following private data members:
 senderId: the identity of the sender, you can use thread name or thread id;
 cardNo: an integer that represents a credit card number;
 amount: an integer that represents the number of chickens to order;
You must use public methods to set and get the private data members. You must decide if these methods need to be synchronized. The instances created from this class are of the OrderObject. 
6. MultiCellBuffer class is used for sending the order from the retailers (clients) to the chickenFarm (server). This class has n data cells (you can simply set n = 2). The number of cells is less than the max number N (you can set N = 5 or enter N from keyboard) of retailers in your experiment. A setOneCell and
getOneCell methods can be defined to write data into and to read data from one of the available cells. You must use a semaphore of value n to manage the cells and use a lock for each cell to ensure the synchronization.
7. Encoder is a class or a method in a class: The Encoder class will convert an OrderObject into a string. You can choose any way to encode the values into a string, as long as you can decode the string to the original order object. You can use a class or a method to implement the Encoder. 
8. Decoder is a class or a method in a class: The Decoder will convert the string back into the OrderObject.
9. Main: The Main thread will perform necessary preparation, create the buffer classes, instantiate the objects, create threads, and start threads.

